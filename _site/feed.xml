<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-16T20:50:28+08:00</updated><id>http://localhost:4000/</id><title type="html">被水淹死的鱼</title><subtitle>个人技术微博</subtitle><author><name>true</name></author><entry><title type="html">Non-parameter model: Naive Bayes</title><link href="http://localhost:4000/2018/10/15/Naive-Bayes.html" rel="alternate" type="text/html" title="Non-parameter model: Naive Bayes" /><published>2018-10-15T00:00:00+08:00</published><updated>2018-10-15T00:00:00+08:00</updated><id>http://localhost:4000/2018/10/15/Naive%20Bayes</id><content type="html" xml:base="http://localhost:4000/2018/10/15/Naive-Bayes.html">&lt;h1 id=&quot;naive-bayes-algorithm&quot;&gt;Naive Bayes algorithm&lt;/h1&gt;

&lt;h2 id=&quot;一-贝叶斯网络和贝叶斯分类器&quot;&gt;一. 贝叶斯网络和贝叶斯分类器&lt;/h2&gt;

&lt;h3 id=&quot;11-贝叶斯概率&quot;&gt;1.1 贝叶斯概率&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bayes/bayes_7.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       下面通过一个简单的例子介绍贝叶斯公式：如上图所示，假设我们有两个盒子，一个红色的，一个蓝色的。红色盒子中有&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;个苹果和&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个橘子，蓝色盒子中有&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;个苹果和&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个橘子。现假定随机选择一个盒子，再从盒子中随机选择一个水果，观察水果种类后放回。假设多次重复这个过程。在例子中我们定义选择盒子为一个随机事件，随机变量记为&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;的取值有两种，&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;（对应红盒子）或&lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;（对应蓝盒子）。同理，在盒子中取水果也为定义为一个随机变量&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;，F取值&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;（苹果）或&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;（橘子）。由此，我们得出以下两个公式：&lt;script type=&quot;math/tex&quot;&gt;P(B = r) = \frac{4}{10}&lt;/script&gt;&lt;script type=&quot;math/tex&quot;&gt;P (B = b) = \frac{6}{10}&lt;/script&gt;  &lt;br /&gt;
       由以上两个公式我们可以得到结论：抽中蓝盒子的概率比抽中红盒子的概率大。如果在我们知道水果种类之前，有人问那个盒子更可能被选中，那么得到的最多的信息就是&lt;code class=&quot;highlighter-rouge&quot;&gt;P(B)&lt;/code&gt;，我们称之为&lt;code class=&quot;highlighter-rouge&quot;&gt;先验概率&lt;/code&gt;。因为他是我们在观察水果种类之前能够得到的概率。  &lt;br /&gt;
       下面我们对水果种类进行研究，可以得到以下公式
&lt;script type=&quot;math/tex&quot;&gt;P(F = a | B = r) = \frac{1}{4}&lt;/script&gt;&lt;script type=&quot;math/tex&quot;&gt;P(F = o | B = r) = \frac{3}{4}&lt;/script&gt;&lt;script type=&quot;math/tex&quot;&gt;P(F = a | B = b) = \frac{3}{4}&lt;/script&gt;&lt;script type=&quot;math/tex&quot;&gt;P(F = o | B = b) = \frac{1}{4}&lt;/script&gt;注意这些公式是归一化的，所以&lt;script type=&quot;math/tex&quot;&gt;P(F = a | B = r) + P(F = o | B = r) = 1&lt;/script&gt;&lt;script type=&quot;math/tex&quot;&gt;P(F = a | B = b) + P(F = o | B = b) = 1&lt;/script&gt; 由概率论的基本规则，可以得出选择一个苹果的整体概率：&lt;script type=&quot;math/tex&quot;&gt;P(F = a) = P(F = a | B = r)P(B = r) + P(F = o | B = b)P(B = b) = \frac{11}{20}&lt;/script&gt;同理可得&lt;script type=&quot;math/tex&quot;&gt;P(F = a) = \frac{9}{20}&lt;/script&gt; 一旦我们知道拿出的是橘子，那么我们能够使用贝叶斯定理来计算在那个盒子中去的的概率&lt;code class=&quot;highlighter-rouge&quot;&gt;P(B|F)&lt;/code&gt;。&lt;script type=&quot;math/tex&quot;&gt;P(B = r|F=o) = \frac{P(F = o|B = r)P(B = r)}{P(F = o)} = \frac{2}{3}&lt;/script&gt;这样的概率我们称之为&lt;code class=&quot;highlighter-rouge&quot;&gt;后验概率&lt;/code&gt;。  &lt;br /&gt;
       由以上内容可以观察到，贝叶斯公式是将先验概率转化为后验概率。贝叶斯公式应用在学习数据时有一下表现。训练数据：&lt;script type=&quot;math/tex&quot;&gt;\cal{D} = \lbrace{t_1, t_2, ... , t_n}\rbrace&lt;/script&gt;参数&lt;script type=&quot;math/tex&quot;&gt;\omega = \lbrace \omega_1, \omega_2, ..., \omega_n\rbrace&lt;/script&gt;在观察到数据之前，我们会对参数&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;作出假设，这由先验公式&lt;code class=&quot;highlighter-rouge&quot;&gt;P=(ω)&lt;/code&gt;的形式给出。观察数据&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;的效果可以通过条件概率&lt;code class=&quot;highlighter-rouge&quot;&gt;P(D|ω)&lt;/code&gt;表达。贝叶斯定理的形式为：&lt;script type=&quot;math/tex&quot;&gt;P(\omega | \cal{D}) = \frac{ P(\cal{D} | \omega)P(\omega)}{P(\cal{D})}&lt;/script&gt; 让我们能够观察后验概率&lt;code class=&quot;highlighter-rouge&quot;&gt;P(ω|D)&lt;/code&gt;，在观测到&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;后估计&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;的不确定性。&lt;code class=&quot;highlighter-rouge&quot;&gt;P(D|ω)&lt;/code&gt;称为&lt;code class=&quot;highlighter-rouge&quot;&gt;似然函数(likelihood function)&lt;/code&gt;，它表达了在不同参数向量&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;下，观测数据出现的可能性大小。上述公式的分母是一个归一化参数，确保左侧是一个合理的概率密度，积分为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;。我们可以用后验概率分布和似然函数来表达贝叶斯定理的分母&lt;script type=&quot;math/tex&quot;&gt;P(\cal{D}) = \int{P(\cal{D}|\omega)·P(\omega)}\,{\rm d}\omega&lt;/script&gt;我们通过自言语言表达贝叶斯定理：&lt;script type=&quot;math/tex&quot;&gt;posterior ∝ likelihood × prior&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;12-高斯分布&quot;&gt;1.2 高斯分布&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bayes/bayes_8.png&quot; alt=&quot;1&quot; /&gt;&lt;br /&gt;
D维向量x的高斯分布定义如下：
&lt;img src=&quot;/assets/bayes/bayes_9.png&quot; alt=&quot;1&quot; /&gt;&lt;br /&gt;
其中D维向量μ被称为均值，D × D的矩阵Σ被称为协方差，|Σ|表示Σ的行列式。
我们假定各次观 测是独立地从高斯分布中抽取的，分布的均值&lt;code class=&quot;highlighter-rouge&quot;&gt;μ&lt;/code&gt;和方差&lt;code class=&quot;highlighter-rouge&quot;&gt;σ2&lt;/code&gt;未知，我们想根据数据集来确定这些参数。独立地从相同的数据点中抽取的数据点被称为独立同分布(independent and identically distributed)，通常缩写成i.i.d.。我们已经看到两个独立事件的联合概率可以由各个事件的边缘概率的乘积得到。由于我们的数据集是独立同分布的，因此给定&lt;code class=&quot;highlighter-rouge&quot;&gt;μ&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;σ2&lt;/code&gt;，我们可以给出数据集的概率:&lt;script type=&quot;math/tex&quot;&gt;p(x | μ,σ_2) = \prod_{n=1}^N{\cal{N}(x_n | μ,σ_2)}&lt;/script&gt;其对数似然函数可以写成：
&lt;img src=&quot;/assets/bayes/bayes_9.png&quot; alt=&quot;1&quot; /&gt;&lt;br /&gt;
现在让我们思考线性拟合问题，曲线拟合问题的目标是能够根据N个输入&lt;code class=&quot;highlighter-rouge&quot;&gt;x = (x1,...,xN)T&lt;/code&gt;组成的数据集和它们对应的目标值&lt;code class=&quot;highlighter-rouge&quot;&gt;t = (t1, . . . , tN )T&lt;/code&gt; ，在给出输入变量&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;的新值的情况下，对目标变量&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;进行预测。我们所构造的对数似然函数为:&lt;script type=&quot;math/tex&quot;&gt;P({\bf {t}}|{\bf{x,\omega}},\beta) = -\frac{\beta}{2}\sum_{n=1}^N{[y(x_n,\omega) - t_n]^2} + \frac{N}{2}ln{\beta} - \frac{N}{2}ln{2\pi}&lt;/script&gt;这些由公式关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;来确定。为了达到这个目的，我们可以省略公式右侧的最后两项，因为他们不依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;。并且，我们注意到，使用一个正的常数系数来缩放对数似然函数并不会改变关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;的最大值的位置， 因此我们可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;来代替系数 &lt;code class=&quot;highlighter-rouge&quot;&gt;β&lt;/code&gt; 。最后，我们不去最大化似然函数，而是等价地去最小化负对数似然函数。于是我们看到，目前为止对于确定&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;的问题来说，最大化似然函数等价于最小化由&lt;script type=&quot;math/tex&quot;&gt;E(\omega) = \frac{\beta}{2}\sum_{n=1}^N{[y - t_n]^2}&lt;/script&gt;定义的平方和误差函数。因此，在高斯噪声的假设下，&lt;strong&gt;平方和误差函数是最大化似 然函数的一个自然结果&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;13-贝叶斯网络&quot;&gt;1.3 贝叶斯网络&lt;/h3&gt;

&lt;p&gt;       贝叶斯网络是一个带有概率注释的有向无环图，图中的每一个结点均表示一个随机变量，图中两结点间若存在着一条弧，则表示这两结点相对应的随机变量是概率相依的，反之则说明这两个随机变量是条件独立的。网络中任意一个结点 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 均有一个相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;条件概率表 (Conditional Probability Table，CPT)&lt;/code&gt;，用以表示结点&lt;code class=&quot;highlighter-rouge&quot;&gt; X&lt;/code&gt; 在其父结点取各可能值时的条件概率。若结点 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 无父结点,则 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPT&lt;/code&gt; 为其先验概率分布。贝叶斯网络的结构及各结点的 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPT&lt;/code&gt; 定义了网络中各变量的概率分布。 
       贝叶斯分类器是用于分类的贝叶斯网络。该网络中应包含类结点 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;，其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 的取值来自于类集合&lt;script type=&quot;math/tex&quot;&gt;( c_1 , c_2 , ... , c_m),&lt;/script&gt;还包含一组结点 &lt;script type=&quot;math/tex&quot;&gt;X = ( X_1 , X_2 , ... , X_n)，&lt;/script&gt;表示用于分类的特征。 对于贝叶斯网络分类器，若某一待分类的样本 &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;，其分类特征值为 &lt;script type=&quot;math/tex&quot;&gt;x = ( x_1 , x_2 , ... , x_n)，&lt;/script&gt; 则样本 &lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt; 属于类别 &lt;code class=&quot;highlighter-rouge&quot;&gt;ci&lt;/code&gt; 的概率&lt;script type=&quot;math/tex&quot;&gt;P( C = c_i　|　 X_1 = x_1 , X_2 = x_2 , ... , X_n = x_n)，( i = 1 ,2 , ... , m)&lt;/script&gt; 应满足下式: &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;P( C = c_i|X = x) = Max\lbrace P(C = c_1|X = x)P(C = c_2|X = x),...,P(C = c_m|X = x)\rbrace&lt;/script&gt;
而由贝叶斯公式:
&lt;script type=&quot;math/tex&quot;&gt;P( C = c_i　|　X = x) = \frac{P( X = x　|　C = c_i) * P( C = c_i)}{P( X = x)}&lt;/script&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;P(C=ci)&lt;/code&gt; 可由领域专家的经验得到,而 &lt;code class=&quot;highlighter-rouge&quot;&gt;P(X=x|C=ci)&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;P(X=x)&lt;/code&gt; 的计算则较困难。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;应用贝叶斯网络分类器进行分类主要分成两阶段：
第一阶段是贝叶斯网络分类器的学习，即从样本数据中构造分类器，包括结构学习和 CPT 学习。
第二阶段是贝叶斯网络分类器的推理，即计算类结点的条件概率，对分类数据进行分类。  &lt;br /&gt;
这两个阶段的时间复杂性均取决于特征值间的依赖程度，甚至可以是 NP 完全问题，因而在实际应用中，往往需要对贝叶斯网络分类器进行简化。根据对特征值间不同关联程度的假设，可以得出各种贝叶斯分类器，Naive Bayes、TAN、BAN、GBN 就是其中较典型、研究较深入的贝叶斯分类器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二-常见的贝叶斯分类器&quot;&gt;二. 常见的贝叶斯分类器&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bayes/bayes_1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       贝叶斯分类器的分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。目前研究较多的贝叶斯分类器主要有四种，分别是:Naive Bayes、TAN、BAN 和 GBN。&lt;/p&gt;

&lt;h3 id=&quot;21-naive-bayes-分类器&quot;&gt;2.1 Naive Bayes 分类器&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;为了简化计算，最简单的情形可以假定各变量 x 是相对独立的，即为 NB(Naive-Bayes)分类器，如图一所示，虽然这种条件独立的假设在许多应用梁宇未必能很好地满足，但这种简化的贝叶斯分类器在许多实际应用中还是得到了较好的分类精度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;22-tan-分类器&quot;&gt;2.2 TAN 分类器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;TAN（Tree Augmented Naive-Bayes）分类器对 NB 分类器进行扩展，允许各特征变量所对应的节点都成一棵树，如图二。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;朴素贝叶斯(NB)的‘朴素’体现在它假设各属性之间没有相互依赖，可以简化贝叶斯公式中`P(x|c)`的计算。但事实上，属性直接完全没有依赖的情况是非常少的。如果简单粗暴用朴素贝叶斯建模，泛化能力和鲁棒性都难以达到令人满意。这就可以引出半朴素贝叶斯了，它假定每个属性最多只依赖一个(或k个)其他属性。它考虑属性间的相互依赖，但假定依赖只有一个(ODE)或k个(kDE)其他属性。这就是半朴素贝叶斯的’半’所体现之处。 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bayes/bayes_1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;常见的半朴素贝叶斯算法SPODE和TAN
    SPODE算法：假设所有属性都依赖同一个属性，这个属性称为“超父”属性。 
    TAN算法：通过最大带权生成树算法确定属性之间的依赖关系，简单点说，就是每个属性找到跟自己最相关的属性，然后形成一个有向边（只能往一个方向）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;23-ban-分类器&quot;&gt;2.3 BAN 分类器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;BAN（BN Augmented Naive-Baye）进一步扩展 TAN 分类器，允许各特征变量所对应的节点构成一个图，如图三。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;24-gbn-分类器&quot;&gt;2.4 GBN 分类器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;GBN（General Bayesian Network）是一种无约束的贝叶斯网络分类器，和前三种贝叶斯网络分类器有较大区别的是，在前三类分类器中均将类变量所对应的节点作为特殊的节点，即是各特征接待你的父节点，而 GBN 中将类节点作为一不同节点，如图四所示。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;三-bayes-估计&quot;&gt;三. Bayes 估计&lt;/h2&gt;
&lt;h3 id=&quot;31-贝叶斯估计&quot;&gt;3.1 贝叶斯估计&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/bayes/bayes_3.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;       朴素贝叶斯分类是将一个未知样本分到几个预先已知类的过程。过程中最重要的就是建立模型，描述预先的数据集或概念集。通过分析由属性描述的样本(或实例，对象等)来构造模型。假定每一个样本都有一个预先定义的类，由一个被称为类标签的属性确定。为建立模型而被分析的数据元组形成训练数据集，该步也称作有指导的学习。 
       在众多的分类模型中，应用最为广泛的两种分类模型是&lt;code class=&quot;highlighter-rouge&quot;&gt;决策树模型(Decision Tree Model)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;朴素贝叶斯模型(Naive Bayesian Model，NBM)&lt;/code&gt;。决策树模型通过构造树来解决分类问题。首先利用训练数据集来构造一棵决策树，一旦树建立起来，它就可为未知样本产生一个分类。 在分类问题中使用决策树模型有很多的优点，决策树便于使用，而且高效；根据决策树可以 很容易地构造出规则，而规则通常易于解释和理解；决策树可很好地扩展到大型数据库中，同时它的大小独立于数据库的大小；决策树模型的另外一大优点就是可以对有许多属性的数 据集构造决策树。决策树模型也有一些缺点，比如处理缺失数据时的困难，过度拟合问题的出现，以及忽略数据集中属性之间的相关性等。
       和决策树模型相比，朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，&lt;code class=&quot;highlighter-rouge&quot;&gt;NBM&lt;/code&gt; 模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，&lt;code class=&quot;highlighter-rouge&quot;&gt;NBM&lt;/code&gt; 模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此， 这是因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;NBM&lt;/code&gt; 模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给 &lt;code class=&quot;highlighter-rouge&quot;&gt;NBM&lt;/code&gt; 模型的正确分类带来了一定影响。在属性个数比较多或者属性之间相关性较大时，&lt;code class=&quot;highlighter-rouge&quot;&gt;NBM&lt;/code&gt; 模型的分类效率比不上决策树模型。而在属性相关性较小时，&lt;code class=&quot;highlighter-rouge&quot;&gt;NBM&lt;/code&gt; 模型的性能最为良好。&lt;/p&gt;

&lt;h3 id=&quot;32-拉普拉斯平滑laplace-smoothing&quot;&gt;3.2 拉普拉斯平滑（Laplace smoothing）&lt;/h3&gt;
&lt;p&gt;       &lt;code class=&quot;highlighter-rouge&quot;&gt;拉普拉斯平滑&lt;/code&gt;在自然语言处理中非常常见。用极大似然估计可能出现所要估计的概率值为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;的情况，这时会影响到后验概率的计算结果，使分类产生偏差。也就是当某个分量在总样本某个分类中（观察样本库/训练集）从没出现过，会导致整个实例的计算结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;。为了解决这个问题，使用拉普拉斯平滑进行处理。   &lt;br /&gt;
       它的思想非常简单，就是对先验概率的分子（划分的计数）加1，分母加上类别数；对条件概率分子加1，分母加上对应特征的可能取值数量。这样在解决零概率问题的同时，也保证了概率和依然为1。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;举个栗子：
假设在文本分类中，有3个类，A、B、C，在指定的训练样本中，某段话F，在各个类中观测计数分别为0，990，10，即概率为P(F/A)=0，P(F/B)=0.99，P(F/C)=0.01，对这三个量使用拉普拉斯平滑的计算方法如下：P(F/A)= 1/1003 = 0.001，P(F/B)= 991/1003=0.988 P(F/C)= 11/1003=0.011
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四-naive-bayes-在分类中的应用&quot;&gt;四. Naive Bayes 在分类中的应用&lt;/h2&gt;
&lt;p&gt;以下是 Tom M.Mitchell 的机器学习中的一个栗子，是对不同环境下是否适合打网球作出预测，很具有代表性。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Play-Tennis Problem&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;Traing Data
 &lt;img src=&quot;/assets/bayes/bayes_4.png&quot; alt=&quot;1&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;Learning
 &lt;img src=&quot;/assets/bayes/bayes_5.png&quot; alt=&quot;1&quot; /&gt;&lt;/li&gt;
    &lt;li&gt;Prediction
 &lt;img src=&quot;/assets/bayes/bayes_6.png&quot; alt=&quot;1&quot; /&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;五-naive-bayes-在拟合中的应用&quot;&gt;五. Naive Bayes 在拟合中的应用&lt;/h2&gt;
&lt;p&gt;       虽然我们已经谈到了先验分布&lt;code class=&quot;highlighter-rouge&quot;&gt;p(ω|α)&lt;/code&gt;，但是我们目前仍然在进行&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;的点估计，这并不是贝叶斯观点。在一个纯粹的贝叶斯方法中，我们应该自始至终地应用概率的加和规则和乘积规则。我们稍后会看到，这需要对所有&lt;code class=&quot;highlighter-rouge&quot;&gt;ω&lt;/code&gt;值进行积分。对于模式识别来说，这种积分是贝叶斯方法的核心。 
       在曲线拟合问题中，我们知道训练数据&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;&lt;/strong&gt;，以及一个新的测试点&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;，我们的目标是预测&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;的值。我们要假设参数α和β是固定已知的。 我们想估计预测分布&lt;script type=&quot;math/tex&quot;&gt;P(t|x, {\bf{x, t}}) = \int{P(t|x, \omega)P({\bf\omega|{x, t}})} \,{\rm d}\omega&lt;/script&gt;简单地说，贝叶斯方法就是自始至终地使用概率的加和规则和乘积规则。
&lt;img src=&quot;/assets/bayes/bayes_11.png&quot; alt=&quot;1&quot; /&gt; 
&lt;img src=&quot;/assets/bayes/bayes_12.png&quot; style=&quot;zoom:50%&quot; /&gt;
用贝叶斯方法处理多项式曲线拟合问题得到的预测分布的结果。使用的多项式为&lt;code class=&quot;highlighter-rouge&quot;&gt;M = 9&lt;/code&gt;，超参数被固定为&lt;code class=&quot;highlighter-rouge&quot;&gt;α = 5 × 10−3&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;β = 11.1&lt;/code&gt;(对应于已知的噪声方差)。其中，红色曲线表示预测概率分布的均值，红色区域对应于均值周围&lt;code class=&quot;highlighter-rouge&quot;&gt;±1&lt;/code&gt;标准差的范围。这个例子来自于《Pattern Recognition and Machine Learning》的贝叶斯曲线拟合。&lt;/p&gt;

&lt;h2 id=&quot;六-参考文献&quot;&gt;六. 参考文献&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;《四种贝叶斯分类器及其比较》邓甦，付长贺    

《Pattern Recognition and Machine Learning》 Christopher M.Bishop    

《统计学习方法》李航

《Machine Learning》 Tom M.Mitchell
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>被水淹死的鱼</name></author><category term="机器学习" /><summary type="html">Naive Bayes algorithm</summary></entry><entry><title type="html">Non-parameter model: KNN</title><link href="http://localhost:4000/2018/10/08/KNN.html" rel="alternate" type="text/html" title="Non-parameter model: KNN" /><published>2018-10-08T00:00:00+08:00</published><updated>2018-10-08T00:00:00+08:00</updated><id>http://localhost:4000/2018/10/08/KNN</id><content type="html" xml:base="http://localhost:4000/2018/10/08/KNN.html">&lt;h1 id=&quot;k-nearest-neighber-algorithm&quot;&gt;K-Nearest Neighber algorithm&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;KNN is a non-parameteric model used for classification and regression. The input considts of the K closest training examples in the feature space.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一-knn-算法决策过程&quot;&gt;一. KNN 算法决策过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/knn/knn_1.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;四角星要被决定赋予哪个类，是白色圆圈还是黑色圆圈?  &lt;br /&gt;
如果 K=3，由于黑色圆圈所占比例为 2/3，四角星将被赋予黑色圆圈那个类。  &lt;br /&gt;
如果 K=7，由于黑色圈圈比例为 5/7，四角星被赋予黑色与圆圈类。&lt;/p&gt;

&lt;p&gt;K 最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的&lt;strong&gt;思路&lt;/strong&gt;是：如果一个样本在特征空间中的 k 个最相似（即特征空间中最邻近）的样本中的大多数属于某一个类别，则该样本也属于这个类别。KNN 算法中，所选择的邻居都是&lt;strong&gt;已经正确分类的对象&lt;/strong&gt;。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。KNN 方法虽然从原理上也依赖于极限定理，但在类别决策时，只与极少量的相邻样本有关。由于 KNN 方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于&lt;strong&gt;类域的交叉或重叠较多&lt;/strong&gt;的待分样本集来说，KNN 方法较其他方法更为适合。KNN 算法不仅可以用于&lt;strong&gt;分类&lt;/strong&gt;，还可以用于&lt;strong&gt;回归&lt;/strong&gt;。通过找出一个样本的 k 个最近邻居， 将这些邻居的属性的平均值赋给该样本，就可以得到该样本的属性。更有用的方法是将不同距离的邻居对该样本产生的影响给予不同的&lt;strong&gt;权值(weight)&lt;/strong&gt;，如权值与距离成正比。&lt;/p&gt;

&lt;h3 id=&quot;11-knn-for-regression-prediction&quot;&gt;1.1 KNN for Regression (Prediction)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/knn/knn_9.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Assume a value for the number of nearest neighbors K and a prediction point x0.&lt;/li&gt;
    &lt;li&gt;KNN identifies the training observations No closest to the prediction point x0.&lt;/li&gt;
    &lt;li&gt;KNN estimates f (x0) using the average of all the responses in N0&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/knn/knn_10.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Q: Any better non-parametric model, do we need to adjust the weights? 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12-度量问题&quot;&gt;1.2 度量问题&lt;/h3&gt;

&lt;h4 id=&quot;121-distance-measure&quot;&gt;1.2.1 Distance Measure&lt;/h4&gt;

&lt;p&gt;关于距离的度量，两点 A，B 之间的距离d，应该有如下性质：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. d(A,B) = d(B,A)		symmery(对称性)
2. d(A,A) = 0		    constancy of self-similarity（自相似性的恒定性）
3. d(A,B) = 0   iff	  A = B		positivity separation（分离性）
4. d(A,B) &amp;lt;= d(A,C) + d(B,C)	trangle inquality
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下简单介绍常见的几种距离：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Euclidean Distance（欧几里得距离）
&lt;img src=&quot;/assets/knn/knn_2.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Manhattan Distance（曼哈顿距离）
&lt;img src=&quot;/assets/knn/knn_3.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Minkowski Distance（闵可夫斯基距离)
&lt;img src=&quot;/assets/knn/knn_4.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hamming Distance（汉明距离）
&lt;img src=&quot;/assets/knn/knn_6.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cosine Distance
&lt;img src=&quot;/assets/knn/knn_5.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;122-edited-measure&quot;&gt;1.2.2 Edited Measure&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;To measure the similarity between two objects, transform one into the other, and measure how much effort it took. The measure of effort becomes the distance measure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;给定固定特征，看样本在特征上的表现，关注是否相同。
&lt;img src=&quot;/assets/knn/knn_11.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二-knn-的不足&quot;&gt;二. KNN 的不足&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;该算法在分类时有个主要的不足是，当&lt;strong&gt;样本不平衡&lt;/strong&gt;时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的 K 个邻居中大容量类的样本占多数。因此可以采用权值的方法(和该样本距离小的邻居权值大)来改进。&lt;/li&gt;
  &lt;li&gt;该方法的另一个不足之处是&lt;strong&gt;计算量较大&lt;/strong&gt;，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的 K 个最近邻点。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。该算法比较适用于样本容量比较大的类域的自动分类，而那 些样本容量较小的类域采用这种算法比较容易产生误分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三-knn-中遇到的问题&quot;&gt;三. KNN 中遇到的问题&lt;/h2&gt;

&lt;h3 id=&quot;31-two-questions&quot;&gt;3.1 Two Questions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;K has to an odd number?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;KNN for &lt;strong&gt;classification&lt;/strong&gt;:  &lt;br /&gt;
如果 K 为&lt;strong&gt;偶数&lt;/strong&gt;，出现的两类别相同，可以根据距离计算离得近的类别，从而进行分类。  &lt;br /&gt;
如果 k 为 &lt;strong&gt;∞&lt;/strong&gt; 时，只需要看两类的个数。  &lt;br /&gt;
如果 k 为 &lt;strong&gt;1&lt;/strong&gt; 时，过拟合。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;KNN for &lt;strong&gt;regression(prediction)&lt;/strong&gt;:  &lt;br /&gt;
求 x 对应点处的 y 值，只需将 x 附近取 K 个点，求 K 个点的 y 的&lt;strong&gt;平均值&lt;/strong&gt;即可。另外取K个均值时，由于每个点的贡献不同，可取相应的&lt;strong&gt;权重&lt;/strong&gt;。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;What if K becomes very large?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/knn/knn_7.png&quot; alt=&quot;1&quot; /&gt;
In two dimensions, the nearest-neighbor algorithm leads to a partitioning of the input space into Voronoi cells, each label led by the category of the training point it contains. In three dimensions, the cells are three-dimensional, and the decision boundary resembles the surface of a crystal.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/knn/knn_8.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KNN 这部分的代码在另一个仓库中：
&amp;lt;https://github.com/provenclei/tensorflow_learning_path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>被水淹死的鱼</name></author><category term="机器学习" /><summary type="html">K-Nearest Neighber algorithm</summary></entry><entry><title type="html">Markdown语法</title><link href="http://localhost:4000/2018/10/06/Markdown%E8%AF%AD%E6%B3%95.html" rel="alternate" type="text/html" title="Markdown语法" /><published>2018-10-06T00:00:00+08:00</published><updated>2018-10-06T00:00:00+08:00</updated><id>http://localhost:4000/2018/10/06/Markdown%E8%AF%AD%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/2018/10/06/Markdown%E8%AF%AD%E6%B3%95.html">&lt;h1 id=&quot;markdown-语法和-mweb-写作使用说明&quot;&gt;Markdown 语法和 MWeb 写作使用说明&lt;/h1&gt;

&lt;h2 id=&quot;markdown-的设计哲学&quot;&gt;Markdown 的设计哲学&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Markdown 的目標是實現「易讀易寫」。
不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。
Markdown 的語法有個主要的目的：用來作為一種網路內容的&lt;em&gt;寫作&lt;/em&gt;用語言。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;本文约定&quot;&gt;本文约定&lt;/h2&gt;

&lt;p&gt;如果有写 &lt;code class=&quot;highlighter-rouge&quot;&gt;效果如下：&lt;/code&gt;， 在 MWeb 编辑状态下只有用 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + R&lt;/code&gt; 预览才可以看效果。&lt;/p&gt;

&lt;h2 id=&quot;标题&quot;&gt;标题&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 第一级标题 `&amp;lt;h1&amp;gt;` 
## 第二级标题 `&amp;lt;h2&amp;gt;` 
###### 第六级标题 `&amp;lt;h6&amp;gt;` 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;h1 id=&quot;第一级标题-h1&quot;&gt;第一级标题 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;&lt;/h1&gt;
&lt;h2 id=&quot;第二级标题-h2&quot;&gt;第二级标题 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;h6 id=&quot;第六级标题-h6&quot;&gt;第六级标题 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;/h6&gt;

&lt;h2 id=&quot;强调&quot;&gt;强调&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*这些文字会生成`&amp;lt;em&amp;gt;`*
_这些文字会生成`&amp;lt;u&amp;gt;`_

**这些文字会生成`&amp;lt;strong&amp;gt;`**
__这些文字会生成`&amp;lt;strong&amp;gt;`__
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 MWeb 中的快捷键为： &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + U&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + I&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + B&lt;/code&gt;
效果如下：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这些文字会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt;&lt;/em&gt;
&lt;em&gt;这些文字会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;u&amp;gt;&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这些文字会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/strong&gt;
&lt;strong&gt;这些文字会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;换行&quot;&gt;换行&lt;/h2&gt;

&lt;p&gt;四个及以上空格加回车。
如果不想打这么多空格，只要回车就为换行，请勾选：&lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Themes&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Translate newlines to &amp;lt;br&amp;gt; tags&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;列表&quot;&gt;列表&lt;/h2&gt;

&lt;h3 id=&quot;无序列表&quot;&gt;无序列表&lt;/h3&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 项目一 无序列表 `* + 空格键`
* 项目二
	* 项目二的子项目一 无序列表 `TAB + * + 空格键`
	* 项目二的子项目二
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 MWeb 中的快捷键为： &lt;code class=&quot;highlighter-rouge&quot;&gt;Option + U&lt;/code&gt;
效果如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;项目一 无序列表 &lt;code class=&quot;highlighter-rouge&quot;&gt;* + 空格键&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;项目二
    &lt;ul&gt;
      &lt;li&gt;项目二的子项目一 无序列表 &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB + * + 空格键&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;项目二的子项目二&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;有序列表&quot;&gt;有序列表&lt;/h3&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 项目一 有序列表 `数字 + . + 空格键`
2. 项目二 
3. 项目三
	1. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键`
	2. 项目三的子项目二
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;项目一 有序列表 &lt;code class=&quot;highlighter-rouge&quot;&gt;数字 + . + 空格键&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;项目二&lt;/li&gt;
  &lt;li&gt;项目三
    &lt;ol&gt;
      &lt;li&gt;项目三的子项目一 有序列表 &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB + 数字 + . + 空格键&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;项目三的子项目二&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;任务列表task-lists&quot;&gt;任务列表（Task lists）&lt;/h3&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- [ ] 任务一 未做任务 `- + 空格 + [ ]`
- [x] 任务二 已做任务 `- + 空格 + [x]`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;任务一 未做任务 &lt;code class=&quot;highlighter-rouge&quot;&gt;- + 空格 + [ ]&lt;/code&gt;&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;任务二 已做任务 &lt;code class=&quot;highlighter-rouge&quot;&gt;- + 空格 + [x]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;图片&quot;&gt;图片&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif)
格式: ![Alt Text](url)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Control + Shift + I&lt;/code&gt; 可插入Markdown语法。
如果是 MWeb 的文档库中的文档，还可以用拖放图片、&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + V&lt;/code&gt; 粘贴、&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + Option + I&lt;/code&gt; 导入这三种方式来增加图片。
效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://zh.mweb.im/asset/img/set-up-git.gif&quot; alt=&quot;GitHub set up&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;email &amp;lt;example@example.com&amp;gt;
[GitHub](http://github.com)
自动生成连接  &amp;lt;http://www.github.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Control + Shift + L&lt;/code&gt; 可插入Markdown语法。
如果是 MWeb 的文档库中的文档，拖放或&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + Option + I&lt;/code&gt; 导入非图片时，会生成连接。
效果如下：&lt;/p&gt;

&lt;p&gt;Email 连接： &lt;a href=&quot;mailto:example@example.com&quot;&gt;example@example.com&lt;/a&gt;
&lt;a href=&quot;http://github.com&quot;&gt;连接标题Github网站&lt;/a&gt;
自动生成连接像： &lt;a href=&quot;http://www.github.com/&quot;&gt;http://www.github.com/&lt;/a&gt; 这样&lt;/p&gt;

&lt;h2 id=&quot;区块引用&quot;&gt;区块引用&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;某某说:
&amp;gt; 第一行引用
&amp;gt; 第二行费用文字
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + Shift + B&lt;/code&gt; 可插入Markdown语法。
效果如下：&lt;/p&gt;

&lt;p&gt;某某说:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;第一行引用
第二行费用文字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;行内代码&quot;&gt;行内代码&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;像这样即可：`&amp;lt;addr&amp;gt;` `code`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + K&lt;/code&gt; 可插入Markdown语法。
效果如下：&lt;/p&gt;

&lt;p&gt;像这样即可：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;addr&amp;gt;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;多行或者一段代码&quot;&gt;多行或者一段代码&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```js
function fancyAlert(arg) {
  if(arg) {
    $.facebox({div:'#foo'})
  }

}
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD + Shift + K&lt;/code&gt; 可插入Markdown语法。
效果如下：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fancyAlert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;facebox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'#foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;顺序图或流程图&quot;&gt;顺序图或流程图&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```sequence
张三-&amp;gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&amp;gt;张三: 忙得吐血，哪有时间写。
```

```flow
st=&amp;gt;start: 开始
e=&amp;gt;end: 结束
op=&amp;gt;operation: 我的操作
cond=&amp;gt;condition: 确认？

st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下（ &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Themes&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Enable sequence &amp;amp; flow chart&lt;/code&gt; 才会看到效果 ）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sequence&quot;&gt;张三-&amp;gt;李四: 嘿，小四儿, 写博客了没?
Note right of 李四: 李四愣了一下，说：
李四--&amp;gt;张三: 忙得吐血，哪有时间写。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-flow&quot;&gt;st=&amp;gt;start: 开始
e=&amp;gt;end: 结束
op=&amp;gt;operation: 我的操作
cond=&amp;gt;condition: 确认？

st-&amp;gt;op-&amp;gt;cond
cond(yes)-&amp;gt;e
cond(no)-&amp;gt;op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多请参考：&lt;a href=&quot;http://bramp.github.io/js-sequence-diagrams/&quot;&gt;http://bramp.github.io/js-sequence-diagrams/&lt;/a&gt;, &lt;a href=&quot;http://adrai.github.io/flowchart.js/&quot;&gt;http://adrai.github.io/flowchart.js/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;表格&quot;&gt;表格&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一格表头 | 第二格表头
--------- | -------------
内容单元格 第一列第一格 | 内容单元格第二列第一格
内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;第一格表头&lt;/th&gt;
      &lt;th&gt;第二格表头&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;内容单元格 第一列第一格&lt;/td&gt;
      &lt;td&gt;内容单元格第二列第一格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内容单元格 第一列第二格 多加文字&lt;/td&gt;
      &lt;td&gt;内容单元格第二列第二格&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;删除线&quot;&gt;删除线&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;加删除线像这样用： ~~删除这些~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;加删除线像这样用： &lt;del&gt;删除这些&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&quot;分隔线&quot;&gt;分隔线&lt;/h2&gt;

&lt;p&gt;以下三种方式都可以生成分隔线：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;***

*****

- - -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mathjax&quot;&gt;MathJax&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;块级公式：
$$	x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$

\\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \\]

行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下（&lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Themes&lt;/code&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;Enable MathJax&lt;/code&gt; 才会看到效果）：&lt;/p&gt;

&lt;p&gt;块级公式：
&lt;script type=&quot;math/tex&quot;&gt;x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;\[ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =
1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}
{1+\frac{e^{-8\pi}} {1+\ldots} } } } \]&lt;/p&gt;

&lt;p&gt;行内公式： $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$&lt;/p&gt;

&lt;h2 id=&quot;脚注footnote&quot;&gt;脚注（Footnote）&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这是一个脚注：[^sample_footnote]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;这是一个脚注：&lt;sup id=&quot;fnref:sample_footnote&quot;&gt;&lt;a href=&quot;#fn:sample_footnote&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;注释和阅读更多&quot;&gt;注释和阅读更多&lt;/h2&gt;

&lt;!-- comment --&gt;
&lt;!-- more --&gt;
&lt;p&gt;Actions-&amp;gt;Insert Read More Comment &lt;em&gt;或者&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Command + .&lt;/code&gt;
&lt;strong&gt;注&lt;/strong&gt; 阅读更多的功能只用在生成网站或博客时。&lt;/p&gt;

&lt;h2 id=&quot;toc&quot;&gt;TOC&lt;/h2&gt;

&lt;p&gt;Markdown 语法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TOC]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:sample_footnote&quot;&gt;
      &lt;p&gt;这里是脚注信息 &lt;a href=&quot;#fnref:sample_footnote&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>被水淹死的鱼</name></author><category term="工具" /><summary type="html">Markdown 语法和 MWeb 写作使用说明</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/2018/05/17/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-05-17T14:05:21+08:00</published><updated>2018-05-17T14:05:21+08:00</updated><id>http://localhost:4000/2018/05/17/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/2018/05/17/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>true</name></author><category term="jekyll" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Hello Jekyll</title><link href="http://localhost:4000/2017/04/18/hello-jekyll.html" rel="alternate" type="text/html" title="Hello Jekyll" /><published>2017-04-18T00:00:00+08:00</published><updated>2017-04-18T00:00:00+08:00</updated><id>http://localhost:4000/2017/04/18/hello-jekyll</id><content type="html" xml:base="http://localhost:4000/2017/04/18/hello-jekyll.html">&lt;blockquote&gt;
  &lt;p&gt;Transform your plain text into static websites and blogs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;welcome&quot;&gt;Welcome&lt;/h1&gt;

&lt;h2 id=&quot;welcome-1&quot;&gt;Welcome&lt;/h2&gt;

&lt;h3 id=&quot;welcome-2&quot;&gt;Welcome&lt;/h3&gt;

&lt;p&gt;This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-jekyll-exactlypermalink&quot;&gt;So what is Jekyll, exactly?Permalink&lt;/h3&gt;

&lt;p&gt;Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like &lt;a href=&quot;https://daringfireball.net/projects/markdown/&quot;&gt;Markdown&lt;/a&gt;) and our &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt; renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free.&lt;/p&gt;

&lt;h3 id=&quot;helpful-hintspermalink&quot;&gt;Helpful HintsPermalink&lt;/h3&gt;

&lt;p&gt;Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for.&lt;/p&gt;

&lt;h3 id=&quot;video-test&quot;&gt;Video Test&lt;/h3&gt;

&lt;iframe type=&quot;text/html&quot; width=&quot;100%&quot; height=&quot;385&quot; src=&quot;http://www.youtube.com/embed/gfmjMWjn-Xg&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</content><author><name>Jekyll</name></author><category term="jekyll" /><summary type="html">Transform your plain text into static websites and blogs. Welcome Welcome Welcome This site aims to be a comprehensive guide to Jekyll. We’ll cover topics such as getting your site up and running, creating and managing your content, customizing the way your site works and looks, deploying to various environments, and give you some advice on participating in the future development of Jekyll itself. So what is Jekyll, exactly?Permalink Jekyll is a simple, blog-aware, static site generator. It takes a template directory containing raw text files in various formats, runs it through a converter (like Markdown) and our Liquid renderer, and spits out a complete, ready-to-publish static website suitable for serving with your favorite web server. Jekyll also happens to be the engine behind GitHub Pages, which means you can use Jekyll to host your project’s page, blog, or website from GitHub’s servers for free. Helpful HintsPermalink Throughout this guide there are a number of small-but-handy pieces of information that can make using Jekyll easier, more interesting, and less hazardous. Here’s what to look out for. Video Test</summary></entry></feed>